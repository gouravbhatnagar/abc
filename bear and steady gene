package com.barclays.sp.lion.service.triparty.util.common;

import java.util.Scanner;

public class BearAndSteadyGene {

    public static void main(String[] args) {
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
        Scanner s = new Scanner(System.in);
        int length = s.nextInt();
        String str = s.nextLine();
        int aCount=0;
        int cCount=0;
        int tCount=0;
        int gCount=0;
        
        for(int i=0; i<str.length(); i++){
            
            if(str.charAt(i) == 'A') {
                aCount++;    
            } else if(str.charAt(i) == 'C') {
                cCount++;    
            } else if(str.charAt(i) == 'T') {
                tCount++;    
            } else if(str.charAt(i) == 'G') {
                gCount++;    
            }
        
        }
        
        int[][] aIndex = new int[2][aCount];
        int[][] cIndex = new int[2][cCount];
        int[][] tIndex = new int[2][tCount];
        int[][] gIndex = new int[2][gCount];
        
        int aIndexCounter = 2;
        int cIndexCounter = 2;
        int tIndexCounter = 2;
        int gIndexCounter = 2;
        //int aCounter = 0;
        //int cCounter = 0;
        //int tCounter = 0;
        //int gCounter = 0;
        
        char prevChar = str.charAt(0);
        char curChar;
        
        if(str.charAt(0) == 'A') {
            aIndex[0][aIndexCounter++] = 0;    
        } else if(str.charAt(0) == 'C') {
            cIndex[0][cIndexCounter++] = 0;    
        } else if(str.charAt(0) == 'T') {
            tIndex[0][tIndexCounter++] = 0;    
        } else if(str.charAt(0) == 'G') {
            gIndex[0][gIndexCounter++] = 0;    
        }   
        
        for(int i=0; i<str.length(); i++){
            
            curChar = str.charAt(i);
            
            if(prevChar!=curChar) {
            
                if(str.charAt(i) == 'A') {
                    aIndex[1][aIndexCounter-1] = i-1;
                    //aCounter = aCounter+aIndex[1][aIndexCounter-1]-aIndex[0][aIndexCounter-1]+1;
                    aIndex[0][aIndexCounter++] = i;    
                } else if(str.charAt(i) == 'C') {
                    cIndex[1][cIndexCounter-1] = i-1; 
                    //cCounter = cCounter+cIndex[1][cIndexCounter-1]-cIndex[0][cIndexCounter-1]+1;
                    cIndex[0][cIndexCounter++] = i;    
                } else if(str.charAt(i) == 'T') {
                    tIndex[1][tIndexCounter-1] = i-1;
                    //tCounter = tCounter+tIndex[1][tIndexCounter-1]-tIndex[0][tIndexCounter-1]+1;
                    tIndex[0][tIndexCounter++] = i;    
                } else if(str.charAt(i) == 'G') {
                    gIndex[1][gIndexCounter-1] = i-1; 
                    //gCounter = gCounter+gIndex[1][gIndexCounter-1]-gIndex[0][gIndexCounter-1]+1;
                    gIndex[0][gIndexCounter++] = i;    
                }
                
            }
            
            prevChar = curChar;
        
        }
        
        if(str.charAt(str.length()-1) == 'A') {
            aIndex[1][aIndexCounter-1] = str.length()-1; 
            //aCounter = aCounter+aIndex[1][aIndexCounter-1]-aIndex[0][aIndexCounter-1]+1;
        } else if(str.charAt(str.length()-1) == 'C') {
            cIndex[1][cIndexCounter-1] = str.length()-1; 
            //cCounter = cCounter+cIndex[1][cIndexCounter-1]-cIndex[0][cIndexCounter-1]+1;
        } else if(str.charAt(str.length()-1) == 'T') {
            tIndex[1][tIndexCounter-1] = str.length()-1;
            //tCounter = tCounter+tIndex[1][tIndexCounter-1]-tIndex[0][tIndexCounter-1]+1;           
        } else if(str.charAt(str.length()-1) == 'G') {
            gIndex[1][gIndexCounter-1] = str.length()-1;    
            //gCounter = gCounter+gIndex[1][gIndexCounter-1]-gIndex[0][gIndexCounter-1]+1;
        }
        
        int idealCount = str.length()/4;
        
        int eligibleSize=0;
        
        if(aCount>idealCount){
            eligibleSize++;    
        }
        
        if(cCount>idealCount){
            eligibleSize++;    
        }
        
        if(tCount>idealCount){
            eligibleSize++;    
        }
        
        if(gCount>idealCount){
            eligibleSize++;    
        }
        
        int[][][] eligibleArr = new int[eligibleSize][][];
        
        eligibleSize=0;
        
        if(aCount>idealCount){
            aIndex[0][0]=idealCount-aCount;
            aIndex[1][0]=0;
            aIndex[0][1]=2;
            aIndex[1][1]=2;

            eligibleArr[eligibleSize++] = aIndex;
        }
        
        if(cCount>idealCount){
            cIndex[0][0]=idealCount-cCount;
            cIndex[1][0]=0;
            cIndex[0][1]=2;
            cIndex[1][1]=2;
            
            eligibleArr[eligibleSize++] = cIndex;
        }
        
        if(tCount>idealCount){
            tIndex[0][0]=idealCount-tCount;
            tIndex[1][0]=0;
            tIndex[0][1]=2;
            tIndex[1][1]=2;
            
            eligibleArr[eligibleSize++] = tIndex;
        }
        
        if(gCount>idealCount){
            gIndex[0][0]=idealCount-gCount;
            gIndex[1][0]=0;
            gIndex[0][1]=2;
            gIndex[1][1]=2;
            
            eligibleArr[eligibleSize++] = gIndex;
        }
        int minimumLen = 999999;
        
        while(true) {
        
            int[][] curArray = null;
            boolean matchFound = true;
            int nearestStartIndex = 999999;
            int nearestEndIndex = 0;
            
            for(int[][] arr:eligibleArr){
            
                if(arr[0][0]>arr[1][0]){
                
                    matchFound = false;
                    
                    if(arr[0][arr[1][1]]<nearestStartIndex){
                        nearestStartIndex=arr[0][arr[1][1]];
                        curArray=arr;
                    }
                
                }
            }
            
            if(matchFound==false){
                curArray[1][0] = curArray[1][0] + curArray[1][curArray[1][1]] - curArray[0][curArray[1][1]] + 1;
                curArray[1][1] = curArray[1][1] + 1;
            } else {
                
                int[][] endArr = curArray;
                int[][] startArr = null;
                int tempMinLen = 0;
                nearestEndIndex=endArr[0][endArr[1][1]-1];
                /*for(int[][] arr:eligibleArr){
            
                    if(arr[0][arr[1][1]-1]>nearestEndIndex){
                        
                        nearestEndIndex=arr[0][arr[1][1]-1];
                        endArr=arr;
                
                    }
                    
                    if(arr[0][arr[0][1]]<nearestStartIndex){
                        
                        nearestStartIndex=arr[0][arr[0][1]];
                        startArr=arr;
                
                    }
                    
                }*/
            
                tempMinLen = nearestEndIndex-nearestStartIndex+1;
                
                if(endArr[1][0]>endArr[0][0] && endArr[1][endArr[1][1]-1]-endArr[0][endArr[1][1]-1]>=endArr[1][0]-endArr[0][0]){
                    
                    tempMinLen = tempMinLen + (endArr[1][0] - endArr[0][0]);
                    endArr[1][0] = endArr[0][0];
                    
                }

                if(minimumLen>tempMinLen){
                    minimumLen=tempMinLen;    
                }
                
                
                while(true){
                
                    nearestStartIndex = 999999;
                    
                    for(int[][] arr:eligibleArr){
                        
                        if(arr[0][arr[0][1]]<nearestStartIndex){
                            
                            nearestStartIndex=arr[0][arr[0][1]];
                            startArr=arr;
                    
                        }
                        
                    }
                    
                    if(startArr[1][0]-startArr[0][0]>startArr[1][startArr[0][1]]-startArr[0][startArr[0][1]]){
                        tempMinLen = tempMinLen - (startArr[1][startArr[0][1]]-startArr[0][startArr[0][1]]);
                        startArr[1][0] = startArr[0][0];
                        startArr[0][1] = startArr[0][1]+1;
                        
                    }else if(startArr[1][0]-startArr[0][0]<startArr[1][startArr[0][1]]-startArr[0][startArr[0][1]]){
                        tempMinLen = tempMinLen - (startArr[1][startArr[0][1]]-startArr[0][startArr[0][1]]) + (startArr[1][0]-startArr[0][0]);
                        if(minimumLen>tempMinLen){
                            minimumLen=tempMinLen;    
                        }
                        startArr[1][0] = startArr[1][0]-(startArr[1][startArr[0][1]]-startArr[0][startArr[0][1]]+1);
                        startArr[0][1] = startArr[0][1]+1;
                        break;
                    }else {
                        tempMinLen = tempMinLen - (startArr[1][startArr[0][1]]-startArr[0][startArr[0][1]]);
                        if(minimumLen>tempMinLen){
                            minimumLen=tempMinLen;    
                        }
                        startArr[1][0] = startArr[1][0]-(startArr[1][startArr[0][1]]-startArr[0][startArr[0][1]]+1);
                        startArr[0][1] = startArr[0][1]+1;
                        break;
                    }
                               
                }
                
                
                
                
            }
            
        }
    }
}
